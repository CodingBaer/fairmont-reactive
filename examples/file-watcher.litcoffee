# Example: Reactive File Watcher

This example build on the previous examples of an echo server and `hello world` web server.
In this example, we're going to generate `change` events from watching a set of files, listen for those events, and run our tests whenever we get one.
We'll also throttle the events so we don't run the tests unnecessarily.

We need a couple of things from the Node APIs so we can watch the files.

    {join} = require "path"
    fs = require "fs"

We also need to pick up some functions from Fairmont.

    {start, flow, events, throttle, map, pull} = require "../src"

    {spread, shell, lsR} = require "fairmont"

This is the directory that contains the files we're watching. In real life, we'd probably get this from the command line or a configuration file.

    src = join __dirname, "..", "src"

As always, we use `start` to run the iterator function returned by `flow`.

    start flow [
      lsR src
      map (path) ->
        start flow [
          events "change", fs.watch path
          throttle 5000
          map spread (event, file) ->
            console.log "Detected change in #{file}"
            shell "npm test"
          pull
          map (s) -> console.log s.stdout
        ]
    ]

We'll initialize our flow with the list of files returned by `lsR`.
The resulting Promise will be coerced into an asynchronous iterator that produces path values.
These are passed into `map`, which starts a nested flow.

We kick this flow off with events generated by Node's FSWatcher.
Since this sometimes generates duplicate events, we `throttle` the events to ignore events that occurr within 5 seconds of the last event we processed.

We get two arguments from the events.
These are passed in as an array, so we use `spread` to convert the array into a list of arguments.
We'll log that we got an event and then run `npm test`.

Since the `shell` function returns a Promise, we have `pull` out the Promise into a value.
Otherwise, we would have gotten a Promise as the argument to our last `map` function.
Finally, we log the output of the shell command via the console.
